{"ast":null,"code":"import { ElementStates } from \"../types/element-states\";\nimport { delay, swap } from \"./utils\";\nimport { Direction } from \"../types/direction\";\nexport const ColumnColor = (index, currentIndex, arr) => {\n  let length = arr.length - 1;\n\n  if (currentIndex > length - index) {\n    return ElementStates.Modified;\n  }\n\n  if (currentIndex === index || currentIndex === length - index) {\n    return ElementStates.Changing;\n  }\n\n  return ElementStates.Default;\n}; // пузырек\n\n_c = ColumnColor;\nexport const bubbleSort = async _ref => {\n  let {\n    arr,\n    direction,\n    setIsLoader,\n    setIsDisabled,\n    setArray\n  } = _ref;\n  setIsLoader(true);\n  setIsDisabled(true);\n\n  for (let j = arr.length - 1; j > 0; j--) {\n    for (let i = 0; i < j; i++) {\n      if (direction === Direction.Ascending ? arr[i] > arr[i + 1] : arr[i] < arr[i + 1]) {\n        swap(arr, i, i + 1);\n        await delay(1000);\n        setArray([...arr]);\n      }\n    }\n  }\n\n  setIsLoader(false);\n  setIsDisabled(false);\n}; // выбор\n\nexport const selectionSort = async _ref2 => {\n  let {\n    arr,\n    direction,\n    setIsLoader,\n    setIsDisabled,\n    setArray\n  } = _ref2;\n  setIsLoader(true);\n  setIsDisabled(true);\n\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (direction === Direction.Descending) {\n      let maxInd = i;\n\n      for (let j = i; j < arr.length; j++) {\n        if (arr[maxInd] < arr[j]) {\n          maxInd = j;\n        }\n      }\n\n      if (i !== maxInd) {\n        swap(arr, i, maxInd);\n        await delay(1000);\n        setArray([...arr]);\n      }\n    } else if (direction === Direction.Ascending) {\n      let minInd = i;\n\n      for (let j = i; j < arr.length; j++) {\n        if (arr[minInd] > arr[j]) {\n          minInd = j;\n        }\n      }\n\n      if (i !== minInd) {\n        swap(arr, i, minInd);\n        await delay(1000);\n        setArray([...arr]);\n      }\n    }\n  }\n\n  setIsLoader(false);\n  setIsDisabled(false);\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"ColumnColor\");","map":{"version":3,"sources":["/Users/svetavo/dev/algososh/src/utils/sort-utils.ts"],"names":["ElementStates","delay","swap","Direction","ColumnColor","index","currentIndex","arr","length","Modified","Changing","Default","bubbleSort","direction","setIsLoader","setIsDisabled","setArray","j","i","Ascending","selectionSort","Descending","maxInd","minInd"],"mappings":"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","sourcesContent":["import { ElementStates } from \"../types/element-states\";\nimport { delay, swap } from \"./utils\";\nimport { Dispatch, SetStateAction } from \"react\";\nimport { Direction } from \"../types/direction\";\n\ntype Dispatcher<S> = Dispatch<SetStateAction<S>>;\n\ninterface IProps {\n  arr: string[];\n  direction: string;\n  setIsLoader: Dispatcher<boolean>;\n  setIsDisabled: Dispatcher<boolean>;\n  setArray: Dispatcher<string[]>;\n}\n\nexport const ColumnColor = (\n  index: number,\n  currentIndex: number,\n  arr: Array<string | number>\n) => {\n  let length = arr.length - 1;\n  if (currentIndex > length - index) {\n    return ElementStates.Modified;\n  }\n  if (currentIndex === index || currentIndex === length - index) {\n    return ElementStates.Changing;\n  }\n  return ElementStates.Default;\n};\n\n// пузырек\nexport const bubbleSort = async ({\n  arr,\n  direction,\n  setIsLoader,\n  setIsDisabled,\n  setArray,\n}: IProps) => {\n  setIsLoader(true);\n  setIsDisabled(true);\n  for (let j = arr.length - 1; j > 0; j--) {\n    for (let i = 0; i < j; i++) {\n      if (\n        direction === Direction.Ascending\n          ? arr[i] > arr[i + 1]\n          : arr[i] < arr[i + 1]\n      ) {\n        swap(arr, i, i + 1);\n        await delay(1000);\n        setArray([...arr]);\n      }\n    }\n  }\n  setIsLoader(false);\n  setIsDisabled(false);\n};\n\n// выбор\nexport const selectionSort = async ({\n  arr,\n  direction,\n  setIsLoader,\n  setIsDisabled,\n  setArray,\n}: IProps) => {\n  setIsLoader(true);\n  setIsDisabled(true);\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (direction === Direction.Descending) {\n      let maxInd = i;\n      for (let j = i; j < arr.length; j++) {\n        if (arr[maxInd] < arr[j]) {\n          maxInd = j;\n        }\n      }\n      if (i !== maxInd) {\n        swap(arr, i, maxInd);\n        await delay(1000);\n        setArray([...arr]);\n      }\n    } else if (direction === Direction.Ascending) {\n      let minInd = i;\n      for (let j = i; j < arr.length; j++) {\n        if (arr[minInd] > arr[j]) {\n          minInd = j;\n        }\n      }\n      if (i !== minInd) {\n        swap(arr, i, minInd);\n        await delay(1000);\n        setArray([...arr]);\n      }\n    }\n  }\n  setIsLoader(false);\n  setIsDisabled(false);\n};\n"]},"metadata":{},"sourceType":"module"}